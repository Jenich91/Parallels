# Parallels

Реализация проекта Parallels.
Разработка на языке программирования C++, с использованием паттерна MVC, графический пользовательский интерфейс на базе QT-библиотеки, программы позволяющая генерировать и отрисовывать идеальные лабиринты(согласно алгоритму Эллера, без изолированных областей и петель, с поиском пути в между двумя точками в любом месте лабиринта), и пещеры(с использованием клеточного автомата, пользователем задаются пределы "рождения" и "смерти" клетки, а также шанс на начальную инициализацию клетки).

## Chapter II

### Многопоточность

**Синхронная программная модель** – это программная модель, в рамках которой каждому потоку назначается набор задач.
Все задачи в рамках потока выполняются последовательно друг за другом, когда завершено выполнение одной задачи, появляется возможность заняться другой.
В этой модели невозможно останавливать выполнение задачи, чтобы в промежутке выполнить другую задачу.

Частным случаем синхронной модели является *однопоточность*. Если имеется несколько задач, которые надлежит выполнить, и текущая система предоставляет один поток, который может работать со всеми задачами, то он берет поочередно одну за другой и процесс выглядит так:

Здесь видно, что имеется поток и 4 задачи, которые необходимо выполнить.
Поток начинает выполнять поочередно одну за одной и выполняет их в итоге все.

В случаях, когда порядок, в котором задачи выполняются, не влияет на результат работы программы, может быть применена *многопоточность*.

Многопоточность является другим случаем синхронной модели – в этом сценарии, используются много потоков, которые могут брать задачи и приступать к работе с ними, т.е. у нас есть пулы потоков и множество задач. \
Итак, многопоточность может работать вот так:

Здесь можно видеть, что у нас есть 4 потока и столько же задач для выполнения, и каждый поток начинает работать с ними.
Это идеальный сценарий, но в обычных условиях используется большее количество задач чем количество доступных потоков, таким образом освободившийся поток получает другое задание. \
Нежелательно каждый раз создавать новые потоки, потому что для этого требуется использование дополнительных системных ресурсов, таких как процессорное время, память. Поэтому изначальное количество потоков должно быть заранее заданным.

### Мьютексы

При написании многопоточных приложений почти всегда требуется работать с общими данными, одновременное изменение которых может привести к очень неприятным последствиям.
Для блокировки общих данных от одновременного доступа необходимо использовать *объекты синхронизации*.

**Мьютекс** (англ. mutex) представляет собой взаимно исключающий синхронизирующий объект.
Это означает, что он может быть получен потоком только по очереди.
Мьютекс предназначен для тех ситуаций, в которых общий ресурс может быть одновременно использован только в одном из потоков.
Допустим, что системный журнал совместно используется в нескольких процессах, но только в одном из них данные могут записываться в файл этого журнала в любой момент времени.
Для синхронизации процессов в данной ситуации идеально подходит мьютекс.

Для описания мьютекса требуется всего один бит, хотя чаще используется целая переменная, у которой 0 означает неблокированное состояние, а все остальные значения соответствуют блокированному состоянию.
Значение мьютекса устанавливается двумя процедурами: захвата и освобождения.
1. Если поток собирается войти в критическую область, он вызывает процедуру захвата.
2. Если мьютекс не заблокирован, запрос выполняется и вызывающий поток может попасть в критическую область.
3. Если мьютекс закрыт, то поток пытающийся войти в критическую секцию блокируется.
4. Если поток собирается выйти из критической области, он, соответственно, вызывает процедуру освобождения.

Принципы работы с мьютексами отличаются в Windows и Linux, но в общем случае можно выделить следующие шаги:
- Создание/Описание
- Открытие/Инициализация
- Попытка захвата и ожидание
- Освобождение

### Метод конвейерного параллелизма

Классическим способом применения многопоточности, в случае, когда необходимо решить одну и ту же задачу для некоторого количества *N* наборов исходных данных, является запуск всего алгоритма в одном потоке.
При таком подходе каждым потоком алгоритм выполняется для *N/(число_потоков)* наборов исходных данных.

**Конвейеризация** (или конвейерная обработка) в общем случае основана на разделении подлежащего исполнению алгоритма на более мелкие части, называемые ступенями, и выделении для каждой из них отдельного потока.
Так обработку любого набора данных можно разделить на несколько этапов, организовав передачу данных от одного этапа к следующему.
Производительность при этом возрастает благодаря тому, что на различных ступенях (в разных потоках) конвейера одновременно обрабатываются разные наборы данных.

В качестве конкретного примера можно привести алгоритм поиска наибольшего числа в строке.
На вход подается массив строк, для каждой из которых нужно выполнить поиск.
В первом потоке будет выполняться разбиение строки на слова, во втором приведение слов к числовому типу данных, в третьем поиск наибольшего среди чисел.
И тогда процесс работы будет выглядеть так:
1. В первом потоке обрабатывается 1-я строка из массива. Остальные строки ожидают своей очереди.
2. Массив слов, полученный после обработки 1-й строки поступает на обработку во 2-й поток. Так как первой поток освободился, в него на обработку поступает 2-я строка.
3. Далее переход между 2-м и 3-м потоками происходит так же, как и между 1-м и 2-м.
4. В случае, если 2-я строка обработалась в 1-м потоке быстрее, чем 1-я строка во 2-м потоке, 2-я строка поступает в очередь ожидающих освобождения 2-го потока. Тем временем, так как первой поток освободился, в него на обработку поступает 3-я строка.

## Part 1. Муравьиный алгоритм

Необходимо реализовать муравьиный алгоритм для решения задачи коммивояжерас применением параллельных вычислений и без них:
- У программы предусмотрен консольный интерфейс
- Пользователем задается матрица для задачи коммивояжера
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов для указанной матрицы
- Измерить время, которое потребуется для выполнения *N* раз муравьиного алгоритма с применением параллелизма для заданной пользователем матрицы
- Измерить время, которое потребуется для выполнения *N* раз обычного муравьиного алгоритма для заданной пользователем матрицы
- На экран вывести полученное в обоих случаях время
- Для блокировки доступа к данным при параллельной реализации, использовать мьютексы

## Part 2. Решение СЛАУ

Необходимо реализовать обычный и параллельный алгоритмы решения СЛАУ методом Гаусса:
- Добавить в существующий Makefile цель "gauss" для сборки программы
- У программы предусмотрен консольный интерфейс
- Пользователем задается матрица, описывающая СЛАУ
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов для указанной СЛАУ
- Измерить время, которое потребуется для выполнения *N* раз параллельного алгоритма решения заданной пользователем СЛАУ
- Измерить время, которое потребуется для выполнения *N* раз обычного алгоритма решения заданной пользователем СЛАУ
- Вывести на экран полученное в обоих случаях время
- Для блокировки доступа к данным при параллельной реализации, использовать мьютексы

## Part 3. Алгоритм Винограда

Необходимо реализовать алгоритм Винограда умножения матриц без применения параллелизма, а также с использованием конвейерного и классического способов параллелизма:
- Выделено 4 стадии работы конвейера
- У программы предусмотрен консольный интерфейс
- Предусмотрено 2 способа ввода:
    - Пользователем задаются обе матриц для умножения
    - Пользователем задаются размерности матриц, которые затем заполняются в программе случайным образом
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов, а также сгенерированные матрицы
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц без применения параллелизма
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц с применением классического параллелизма при количестве потоков, равном 2, 4, 8, ..., 4 * (число логических процессоров компьютера)
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц с применением конвейерного параллелизма
- Вывести на экран полученное в каждом случае время
